package me.feng3d.core.base.subgeometry
{
	import flash.display3D.Context3DVertexBufferFormat;
	import flash.geom.Matrix3D;
	
	import me.feng3d.arcane;
	import me.feng3d.core.base.ISubGeometry;
	import me.feng3d.core.buffer.Context3DBufferTypeID;
	import me.feng3d.core.buffer.context3d.VABuffer;
	import me.feng3d.core.proxy.Context3DCache;

	use namespace arcane;

	/**
	 * 子几何体
	 */
	public class SubGeometry extends SubGeometryBase implements ISubGeometry
	{
		/** 顶点uv数据 */
		protected var _uvs:Vector.<Number>;

		/** 顶点uv数据缓冲 */
		protected var _uvBuffer:VABuffer;

		private var _scaleU:Number = 1;
		private var _scaleV:Number = 1;

		protected var _uvsDirty:Boolean = true;

		protected var _autoGenerateUVs:Boolean = false;

		/** 顶点法线 */
		protected var _vertexNormals:Vector.<Number>;

		/** 顶点切线 */
		protected var _vertexTangents:Vector.<Number>;
		
		/** 顶点法线数据缓冲 */
		protected var _normalBuffer:VABuffer;
		
		/** 顶点切线数据缓冲 */
		protected var _tangentBuffer:VABuffer;

		/**
		 * 创建一个新几何体
		 */
		public function SubGeometry()
		{
			super();
		}

		override protected function initBuffers():void
		{
			super.initBuffers();
			
			_uvBuffer = new VABuffer(Context3DBufferTypeID.UV_VA_2, updateUVBuffer);
			_normalBuffer = new VABuffer(Context3DBufferTypeID.NORMAL_VA_3, updateNormalBuffer);
			_tangentBuffer = new VABuffer(Context3DBufferTypeID.TANGENT_VA_3, updateTangentBuffer);
		}

		override public function collectCache(context3dCache:Context3DCache):void
		{
			super.collectCache(context3dCache);
			context3dCache.addDataBuffer(_uvBuffer);
			context3dCache.addDataBuffer(_normalBuffer);
			context3dCache.addDataBuffer(_tangentBuffer);
		}

		override public function releaseCache(context3dCache:Context3DCache):void
		{
			super.releaseCache(context3dCache);
			
			context3dCache.removeDataBuffer(_uvBuffer);
			context3dCache.removeDataBuffer(_normalBuffer);
			context3dCache.removeDataBuffer(_tangentBuffer);
		}

		public function clone():ISubGeometry
		{
			var clone:SubGeometry = new SubGeometry();
			clone.updateVertexData(tvertexData.concat());
			clone.updateUVData(_uvs.concat());
			clone.updateIndexData(_indices.concat());
			return clone;
		}

		override public function dispose():void
		{
			super.dispose();
			_uvs = null;
		}

		override public function get vertexPositionData():Vector.<Number>
		{
			return tvertexData;
		}

		override public function get UVData():Vector.<Number>
		{
			if (_uvsDirty && _autoGenerateUVs)
				_uvs = updateDummyUVs(_uvs);
			return _uvs;
		}

		/**
		 * 更新uv数据
		 */
		public function updateUVData(uvs:Vector.<Number>):void
		{
			_uvs = uvs;

			_uvBuffer.invalid();
		}

		public function fromVectors(vertices:Vector.<Number>, uvs:Vector.<Number>):void
		{
			updateVertexData(vertices);
			updateUVData(uvs);
		}

		override public function get vertexNormalStride():uint
		{
			return 3;
		}

		override public function get vertexNormalOffset():int
		{
			return 0;
		}
		
		override public function get vertexTangentStride():uint
		{
			return 3;
		}
		
		override public function get vertexTangentOffset():int
		{
			return 0;
		}
		
		override public function get UVStride():uint
		{
			return 2;
		}

		override public function get UVOffset():int
		{
			return 0;
		}

		public function get scaleU():Number
		{
			return _scaleU;
		}

		public function get scaleV():Number
		{
			return _scaleV;
		}

		/**
		 * 是否自动生成虚拟uv
		 */
		public function get autoGenerateDummyUVs():Boolean
		{
			return _autoGenerateUVs;
		}

		public function set autoGenerateDummyUVs(value:Boolean):void
		{
			_autoGenerateUVs = value;
			_uvsDirty = value;
		}

		/**
		 * 更新虚拟uv
		 * @param target 虚拟uv(输出)
		 * @return 虚拟uv
		 */		
		protected function updateDummyUVs(target:Vector.<Number>):Vector.<Number>
		{
			_uvBuffer.invalid();

			_uvsDirty = false;

			var idx:uint, uvIdx:uint;
			var stride:int = UVStride;
			var skip:int = stride - 2;
			var len:uint = tvertexData.length / vertexStride * stride;

			if (!target)
				target = new Vector.<Number>();
			target.fixed = false;
			target.length = len;
			target.fixed = true;

			idx = UVOffset;
			uvIdx = 0;
			while (idx < len)
			{
				target[idx++] = uvIdx * .5;
				target[idx++] = 1.0 - (uvIdx & 1);
				idx += skip;

				if (++uvIdx == 3)
					uvIdx = 0;
			}

			return target;
		}

		public function scaleUV(scaleU:Number = 1, scaleV:Number = 1):void
		{
			var offset:int = UVOffset;
			var stride:int = UVStride;
			var uvs:Vector.<Number> = UVData;
			var len:int = uvs.length;
			var ratioU:Number = scaleU / _scaleU;
			var ratioV:Number = scaleV / _scaleV;

			for (var i:uint = offset; i < len; i += stride)
			{
				uvs[i] *= ratioU;
				uvs[i + 1] *= ratioV;
			}

			_scaleU = scaleU;
			_scaleV = scaleV;

			_uvBuffer.invalid();
		}

		protected function updateUVBuffer():void
		{
			_uvBuffer.update(UVData, numVertices, UVStride, UVOffset, Context3DVertexBufferFormat.FLOAT_2);
		}

		override public function get vertexNormalData():Vector.<Number>
		{
			if (_autoDeriveVertexNormals && _vertexNormalsDirty)
				_vertexNormals = updateVertexNormals(_vertexNormals);
			return _vertexNormals;
		}
		
		override public function get vertexTangentData():Vector.<Number>
		{
			if (_autoDeriveVertexTangents && _vertexTangentsDirty)
				_vertexTangents = updateVertexTangents(_vertexTangents);
			return _vertexTangents;
		}
		
		protected function updateNormalBuffer():void
		{
			_normalBuffer.update(vertexNormalData, numVertices, vertexNormalStride, vertexNormalOffset, Context3DVertexBufferFormat.FLOAT_3);
		}
		
		protected function updateTangentBuffer():void
		{
			_tangentBuffer.update(vertexTangentData, numVertices, vertexTangentStride, vertexTangentOffset, Context3DVertexBufferFormat.FLOAT_3);
		}

		override protected function updateVertexNormals(target:Vector.<Number>):Vector.<Number>
		{
			_normalBuffer.invalid();

			return super.updateVertexNormals(target);
		}
		
		override protected function updateVertexTangents(target:Vector.<Number>):Vector.<Number>
		{
			if (_vertexNormalsDirty)
				_vertexNormals = updateVertexNormals(_vertexNormals);
			_tangentBuffer.invalid();
			return super.updateVertexTangents(target);
		}
		
		override public function applyTransformation(transform:Matrix3D):void
		{
			super.applyTransformation(transform);
			_uvBuffer.invalid();
			_normalBuffer.invalid();
			_tangentBuffer.invalid();
		}
		
		override protected function disposeAllVertexBuffers():void
		{
			super.disposeAllVertexBuffers();
			_uvBuffer.invalid();
			_normalBuffer.invalid();
			_tangentBuffer.invalid();
		}
		
		public function updateNormalData(target:Vector.<Number>):void
		{
			_vertexNormals = target;
			_normalBuffer.invalid();
		}
	}
}
